# -*- coding: utf-8 -*-
"""
================================================================================
V4 DCA + AI Hybrid No-Filter Backtest (定期定額 + AI 混合策略無濾網回測)
================================================================================
測試 V4 模型在「定期定額 + AI 自由操作」混合策略下的交易績效。

投資策略:
- 每年年初獲得 60 萬新資金
- 一半 (約 30 萬) 分 12 個月定期定額投入，買入後不能賣出
- 另一半 (約 30 萬) 由 AI 自由決定買賣時機
- 每年年初：新資金 + 上年未投入現金 = 新可投入金額，再對半分配

比較基準:
1. 純定期定額：每月 5 萬元
2. 年初一次投入：每年 60 萬 Buy & Hold

作者：Phil Liang (Generated by Gemini)
日期：2025-12-08
================================================================================
"""

import os
import sys
import pickle
import argparse
from datetime import datetime

# Windows UTF-8 設定
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from stable_baselines3 import PPO

# 中文字型設定
plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

# =============================================================================
# 設定
# =============================================================================
PROJECT_PATH = os.path.dirname(os.path.abspath(__file__))
V4_MODELS_PATH = os.path.join(PROJECT_PATH, 'models_hybrid_v4')
RESULTS_PATH = os.path.join(PROJECT_PATH, 'results_backtest_v4_dca_hybrid_no_filter')
CACHE_DIR = os.path.join(PROJECT_PATH, 'data', 'processed')

DEFAULT_START_DATE = '2023-01-01'  # 預設回測起始日
DEFAULT_END_DATE = None
YEARLY_CAPITAL = 600_000  # 每年新增資金
MONTHLY_DCA_BENCHMARK = 50_000  # 純定期定額基準：每月 5 萬


def parse_args():
    """解析命令列參數"""
    parser = argparse.ArgumentParser(
        description='V4 DCA + AI Hybrid No-Filter Backtest - 定期定額與 AI 混合策略無濾網回測',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
使用範例:
  python backtest_v4_dca_hybrid_no_filter.py                           # 使用預設日期 (2023-01-01 至今)
  python backtest_v4_dca_hybrid_no_filter.py --start 2020-01-01        # 從 2020-01-01 開始回測
  python backtest_v4_dca_hybrid_no_filter.py --start 2020-01-01 --end 2023-12-31
        '''
    )
    parser.add_argument(
        '--start', 
        type=str, 
        default=DEFAULT_START_DATE,
        help=f'回測開始日期 (YYYY-MM-DD 格式，預設: {DEFAULT_START_DATE})'
    )
    parser.add_argument(
        '--end', 
        type=str, 
        default=DEFAULT_END_DATE,
        help='回測結束日期 (YYYY-MM-DD 格式，預設: 最新資料)'
    )
    return parser.parse_args()


def load_lstm_models_for_backtest(cutoff_date):
    """
    載入 LSTM 模型，使用指定的 cutoff_date 進行模型選擇
    
    這確保選擇的模型 train_end < cutoff_date，避免回測時的資料洩漏
    
    Args:
        cutoff_date: date object，模型的 train_end 必須早於此日期
    """
    import ptrl_hybrid_system as hybrid
    import twii_model_registry_multivariate as lstm_1d_module
    import twii_model_registry_5d as lstm_5d_module
    
    print(f"\n[LSTM] Loading models with cutoff_date: {cutoff_date}")
    print(f"[LSTM] Only models with train_end < {cutoff_date} will be considered")
    
    # 使用 cutoff_date 選擇模型 (而非 date.today())
    meta_1d = lstm_1d_module.select_best_model(cutoff_date)
    if meta_1d is None:
        print("[Error] No valid T+1 model found")
        return False
    
    model_1d, scaler_feat_1d, scaler_tgt_1d, _ = lstm_1d_module.load_artifacts(
        meta_1d['train_start'], meta_1d['train_end'])
    print(f"  T+1 Model: {meta_1d['train_start']} ~ {meta_1d['train_end']}")
    
    meta_5d = lstm_5d_module.select_best_model(cutoff_date)
    if meta_5d is None:
        print("[Error] No valid T+5 model found")
        return False
    
    model_5d, scaler_feat_5d, scaler_tgt_5d, _ = lstm_5d_module.load_artifacts(
        meta_5d['train_start'], meta_5d['train_end'])
    print(f"  T+5 Model: {meta_5d['train_start']} ~ {meta_5d['train_end']}")
    
    # 注入到 hybrid 模組的全域變數
    hybrid._LSTM_MODELS.update({
        'model_1d': model_1d, 'scaler_feat_1d': scaler_feat_1d,
        'scaler_tgt_1d': scaler_tgt_1d, 'meta_1d': meta_1d,
        'model_5d': model_5d, 'scaler_feat_5d': scaler_feat_5d,
        'scaler_tgt_5d': scaler_tgt_5d, 'meta_5d': meta_5d, 'loaded': True
    })
    
    return True


# =============================================================================
# DCA + AI Hybrid 回測器
# =============================================================================
class DCAHybridBacktester:
    """
    DCA + AI 混合策略回測器
    
    策略邏輯:
    1. 每年年初獲得 YEARLY_CAPITAL (60萬)
    2. 可用資金 = 新資金 + AI 帳戶未投入現金
    3. 一半分 12 個月定期定額 (買入後不賣)
    4. 一半由 AI 自由操作 (可買可賣)
    """
    def __init__(self, buy_model, sell_model, yearly_capital=600_000):
        self.buy_model = buy_model
        self.sell_model = sell_model
        self.yearly_capital = yearly_capital
        
        # 交易記錄
        self.trades = []
        self.equity_curve = []
        self.dca_buy_signals = []      # DCA 買入點
        self.ai_buy_signals = []       # AI 買入點
        self.ai_sell_signals = []      # AI 賣出點
        
        # 總投入金額追蹤
        self.total_invested = 0
    
    def run(self, df: pd.DataFrame, feature_cols: list) -> dict:
        """執行 DCA + AI Hybrid 回測"""
        
        features = df[feature_cols].values.astype(np.float32)
        close_prices = df['Close'].values
        dates = df.index
        
        # =================================================================
        # 初始化狀態
        # =================================================================
        dca_shares = 0          # 定期定額累積股數 (不可賣出)
        dca_cash = 0            # 本年度待分配的 DCA 現金
        dca_monthly = 0         # 每月 DCA 金額
        
        ai_cash = 0             # AI 可操作現金
        ai_position = None      # AI 持倉 {'shares', 'buy_price', 'buy_date', 'buy_idx'}
        
        current_year = None
        last_dca_month = None
        
        print(f"[Backtest] Period: {dates[0].strftime('%Y-%m-%d')} ~ {dates[-1].strftime('%Y-%m-%d')}")
        print(f"[Backtest] Data points: {len(df)}")
        print(f"[Backtest] Yearly capital: ${self.yearly_capital:,.0f}")
        print("[Backtest] Mode: DCA + AI Hybrid (50% DCA / 50% AI)")
        
        for i in range(len(df)):
            date = dates[i]
            price = close_prices[i]
            year = date.year
            month = date.month
            
            # =================================================================
            # 年初：資金注入與分配
            # =================================================================
            if current_year != year:
                # 新的一年開始
                current_year = year
                last_dca_month = None
                
                # 計算可分配資金 = 新資金 + AI 帳戶剩餘現金
                new_fund = self.yearly_capital + ai_cash
                self.total_invested += self.yearly_capital
                
                # 對半分配
                dca_cash = new_fund / 2
                ai_cash = new_fund / 2
                
                # 計算每月 DCA 金額
                dca_monthly = dca_cash / 12
                
                print(f"  [{year}] New year capital injection: ${self.yearly_capital:,.0f}")
                print(f"        Total available: ${new_fund:,.0f} -> DCA: ${dca_cash:,.0f}, AI: ${ai_cash:,.0f}")
            
            # =================================================================
            # 定期定額：每月初買入
            # =================================================================
            if last_dca_month != month and dca_cash > 0:
                last_dca_month = month
                invest_amount = min(dca_monthly, dca_cash)
                
                if invest_amount > price:  # 至少能買 1 股
                    shares_to_buy = int(invest_amount / price)
                    cost = shares_to_buy * price
                    dca_cash -= cost
                    dca_shares += shares_to_buy
                    self.dca_buy_signals.append((date, price, shares_to_buy))
            
            # =================================================================
            # 計算每日淨值
            # =================================================================
            dca_value = dca_shares * price
            ai_stock_value = ai_position['shares'] * price if ai_position else 0
            total_value = dca_value + dca_cash + ai_cash + ai_stock_value
            
            self.equity_curve.append({
                'date': date, 
                'value': total_value,
                'dca_value': dca_value + dca_cash,
                'ai_value': ai_cash + ai_stock_value
            })
            
            # =================================================================
            # AI 操作邏輯
            # =================================================================
            obs = np.nan_to_num(features[i], nan=0.0, posinf=1.0, neginf=-1.0)
            
            # --- AI 持倉中：檢查賣出 ---
            if ai_position is not None:
                hold_days = i - ai_position['buy_idx']
                current_return = price / ai_position['buy_price']
                
                sell_obs = np.concatenate([obs, [current_return]]).astype(np.float32)
                action, _ = self.sell_model.predict(sell_obs.reshape(1, -1), deterministic=True)
                
                stop_loss = current_return < 0.92
                should_sell = action[0] == 1 or stop_loss or hold_days >= 120
                
                if should_sell:
                    sell_value = ai_position['shares'] * price
                    profit = sell_value - ai_position['shares'] * ai_position['buy_price']
                    ai_cash += sell_value
                    
                    self.trades.append({
                        'type': 'AI',
                        'buy_date': ai_position['buy_date'],
                        'buy_price': ai_position['buy_price'],
                        'sell_date': date,
                        'sell_price': price,
                        'return': current_return - 1,
                        'profit': profit,
                        'hold_days': hold_days
                    })
                    self.ai_sell_signals.append((date, price))
                    ai_position = None
            
            # --- AI 空手：檢查買入 ---
            elif ai_position is None and ai_cash > price:
                buy_obs = obs.reshape(1, -1)
                action, _ = self.buy_model.predict(buy_obs, deterministic=True)
                
                if action[0] == 1:  # Buy
                    invest_amount = ai_cash * 0.9
                    shares = int(invest_amount / price)
                    
                    if shares > 0:
                        cost = shares * price
                        ai_cash -= cost
                        
                        ai_position = {
                            'shares': shares,
                            'buy_price': price,
                            'buy_date': date,
                            'buy_idx': i
                        }
                        self.ai_buy_signals.append((date, price))
        
        return self._calculate_metrics(df)
    
    def _calculate_metrics(self, df: pd.DataFrame) -> dict:
        """計算績效指標"""
        if not self.equity_curve:
            return {}
        
        equity_df = pd.DataFrame(self.equity_curve)
        equity_df['date'] = pd.to_datetime(equity_df['date'])
        equity_df.set_index('date', inplace=True)
        
        final = equity_df['value'].iloc[-1]
        total_return = (final - self.total_invested) / self.total_invested if self.total_invested > 0 else 0
        
        days = (equity_df.index[-1] - equity_df.index[0]).days
        years = days / 365.0
        annualized_return = (1 + total_return) ** (1 / years) - 1 if years > 0 else 0
        
        daily_returns = equity_df['value'].pct_change().dropna()
        if len(daily_returns) > 0 and daily_returns.std() > 0:
            sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252))
        else:
            sharpe = 0
        
        rolling_max = equity_df['value'].cummax()
        drawdown = (equity_df['value'] - rolling_max) / rolling_max
        max_drawdown = drawdown.min()
        
        if self.trades:
            wins = sum(1 for t in self.trades if t['return'] > 0)
            win_rate = wins / len(self.trades)
            avg_return = np.mean([t['return'] for t in self.trades])
            avg_hold_days = np.mean([t['hold_days'] for t in self.trades])
        else:
            win_rate = 0
            avg_return = 0
            avg_hold_days = 0
        
        return {
            'total_invested': self.total_invested,
            'final_value': final,
            'total_return': total_return,
            'annualized_return': annualized_return,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_drawdown,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'avg_return': avg_return,
            'avg_hold_days': avg_hold_days,
            'equity_df': equity_df,
            'dca_buys': len(self.dca_buy_signals),
            'ai_buys': len(self.ai_buy_signals)
        }


# =============================================================================
# Benchmark 計算
# =============================================================================
def calculate_pure_dca(df: pd.DataFrame, monthly_amount: float = 50_000):
    """計算純定期定額策略 (每月固定金額)"""
    close_prices = df['Close'].values
    dates = df.index
    
    shares = 0
    total_invested = 0
    equity_curve = []
    last_month = None
    
    for i in range(len(df)):
        date = dates[i]
        price = close_prices[i]
        month = (date.year, date.month)
        
        # 每月初投入
        if last_month != month:
            last_month = month
            shares_to_buy = int(monthly_amount / price)
            if shares_to_buy > 0:
                shares += shares_to_buy
                total_invested += shares_to_buy * price
        
        equity_curve.append({'date': date, 'value': shares * price})
    
    equity_df = pd.DataFrame(equity_curve)
    equity_df['date'] = pd.to_datetime(equity_df['date'])
    equity_df.set_index('date', inplace=True)
    
    final = equity_df['value'].iloc[-1]
    total_return = (final - total_invested) / total_invested if total_invested > 0 else 0
    
    days = (equity_df.index[-1] - equity_df.index[0]).days
    years = days / 365.0
    annualized = (1 + total_return) ** (1 / years) - 1 if years > 0 else 0
    
    daily_returns = equity_df['value'].pct_change().dropna()
    sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252)) if daily_returns.std() > 0 else 0
    
    max_dd = ((equity_df['value'] - equity_df['value'].cummax()) / equity_df['value'].cummax()).min()
    
    return {
        'total_invested': total_invested,
        'final_value': final,
        'total_return': total_return,
        'annualized_return': annualized,
        'sharpe_ratio': sharpe,
        'max_drawdown': max_dd,
        'equity_df': equity_df
    }


def calculate_yearly_lumpsum(df: pd.DataFrame, yearly_amount: float = 600_000):
    """計算年初一次投入 Buy & Hold 策略"""
    close_prices = df['Close'].values
    dates = df.index
    
    shares = 0
    total_invested = 0
    equity_curve = []
    current_year = None
    
    for i in range(len(df)):
        date = dates[i]
        price = close_prices[i]
        year = date.year
        
        # 每年年初投入
        if current_year != year:
            current_year = year
            shares_to_buy = int(yearly_amount / price)
            if shares_to_buy > 0:
                shares += shares_to_buy
                total_invested += shares_to_buy * price
        
        equity_curve.append({'date': date, 'value': shares * price})
    
    equity_df = pd.DataFrame(equity_curve)
    equity_df['date'] = pd.to_datetime(equity_df['date'])
    equity_df.set_index('date', inplace=True)
    
    final = equity_df['value'].iloc[-1]
    total_return = (final - total_invested) / total_invested if total_invested > 0 else 0
    
    days = (equity_df.index[-1] - equity_df.index[0]).days
    years = days / 365.0
    annualized = (1 + total_return) ** (1 / years) - 1 if years > 0 else 0
    
    daily_returns = equity_df['value'].pct_change().dropna()
    sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252)) if daily_returns.std() > 0 else 0
    
    max_dd = ((equity_df['value'] - equity_df['value'].cummax()) / equity_df['value'].cummax()).min()
    
    return {
        'total_invested': total_invested,
        'final_value': final,
        'total_return': total_return,
        'annualized_return': annualized,
        'sharpe_ratio': sharpe,
        'max_drawdown': max_dd,
        'equity_df': equity_df
    }


# =============================================================================
# 主程式
# =============================================================================
def main():
    args = parse_args()
    
    # 驗證日期
    try:
        start_date = pd.Timestamp(args.start)
    except:
        print(f"[Error] Invalid start date: {args.start}")
        sys.exit(1)
    
    end_date = None
    if args.end:
        try:
            end_date = pd.Timestamp(args.end)
        except:
            print(f"[Error] Invalid end date: {args.end}")
            sys.exit(1)
        if end_date <= start_date:
            print(f"[Error] End date must be after start date")
            sys.exit(1)
    
    print("=" * 70)
    print("V4 DCA + AI Hybrid No-Filter Backtest")
    print("=" * 70)
    print(f"  Start: {args.start}")
    print(f"  End:   {args.end if args.end else 'Latest'}")
    print(f"  Yearly Capital: ${YEARLY_CAPITAL:,.0f}")
    print(f"  Strategy: 50% DCA (12 months) + 50% AI Trading")
    
    os.makedirs(RESULTS_PATH, exist_ok=True)
    
    # =========================================================================
    # 載入模型
    # =========================================================================
    print("\n[Model] Loading V4 models...")
    buy_path = os.path.join(V4_MODELS_PATH, 'ppo_buy_twii_final.zip')
    sell_path = os.path.join(V4_MODELS_PATH, 'ppo_sell_twii_final.zip')
    
    if not os.path.exists(buy_path):
        print(f"[Error] Model not found: {buy_path}")
        sys.exit(1)
    
    buy_model = PPO.load(buy_path)
    sell_model = PPO.load(sell_path)
    print("  Models loaded")
    
    # =========================================================================
    # 載入資料
    # =========================================================================
    print("\n[Data] Loading data...")
    import ptrl_hybrid_system as hybrid
    
    # 使用回測 start_date 來選擇 LSTM 模型 (避免資料洩漏)
    if not load_lstm_models_for_backtest(start_date.date()):
        print("[Error] Failed to load LSTM models")
        sys.exit(1)
    
    cache_path = os.path.join(CACHE_DIR, "_TWII_features.pkl")
    if os.path.exists(cache_path):
        with open(cache_path, 'rb') as f:
            twii_full_df = pickle.load(f)
    else:
        # [Modify] 使用本地資料載入函數
        twii_raw = hybrid._load_local_twii_data(start_date="2000-01-01")
        twii_full_df = hybrid.calculate_features(twii_raw, twii_raw, ticker="^TWII", use_cache=True)
    
    # 過濾日期
    twii_backtest_df = twii_full_df[twii_full_df.index >= start_date]
    if end_date:
        twii_backtest_df = twii_backtest_df[twii_backtest_df.index <= end_date]
    
    if len(twii_backtest_df) == 0:
        print(f"[Error] No data in range")
        sys.exit(1)
    
    print(f"  Period: {twii_backtest_df.index[0].strftime('%Y-%m-%d')} ~ {twii_backtest_df.index[-1].strftime('%Y-%m-%d')}")
    
    # =========================================================================
    # 執行回測
    # =========================================================================
    print("\n[Backtest] Running DCA + AI Hybrid strategy...")
    backtester = DCAHybridBacktester(buy_model, sell_model, YEARLY_CAPITAL)
    metrics = backtester.run(twii_backtest_df, hybrid.FEATURE_COLS)
    
    # 計算基準
    print("\n[Benchmark] Calculating benchmarks...")
    dca_bench = calculate_pure_dca(twii_backtest_df, MONTHLY_DCA_BENCHMARK)
    lump_bench = calculate_yearly_lumpsum(twii_backtest_df, YEARLY_CAPITAL)
    
    # =========================================================================
    # 印出績效比較
    # =========================================================================
    print("\n" + "=" * 90)
    print("Performance Comparison: DCA+AI Hybrid vs Pure DCA vs Yearly Lump Sum")
    print("=" * 90)
    print(f"{'Metric':<20} {'DCA+AI Hybrid':>20} {'Pure DCA (50k/mo)':>20} {'Yearly Lump Sum':>20}")
    print("-" * 90)
    print(f"{'Total Invested':<20} ${metrics['total_invested']:>18,.0f} ${dca_bench['total_invested']:>18,.0f} ${lump_bench['total_invested']:>18,.0f}")
    print(f"{'Final Value':<20} ${metrics['final_value']:>18,.0f} ${dca_bench['final_value']:>18,.0f} ${lump_bench['final_value']:>18,.0f}")
    print(f"{'Total Return':<20} {metrics['total_return']*100:>19.2f}% {dca_bench['total_return']*100:>19.2f}% {lump_bench['total_return']*100:>19.2f}%")
    print(f"{'Annualized Return':<20} {metrics['annualized_return']*100:>19.2f}% {dca_bench['annualized_return']*100:>19.2f}% {lump_bench['annualized_return']*100:>19.2f}%")
    print(f"{'Sharpe Ratio':<20} {metrics['sharpe_ratio']:>20.2f} {dca_bench['sharpe_ratio']:>20.2f} {lump_bench['sharpe_ratio']:>20.2f}")
    print(f"{'Max Drawdown':<20} {metrics['max_drawdown']*100:>19.2f}% {dca_bench['max_drawdown']*100:>19.2f}% {lump_bench['max_drawdown']*100:>19.2f}%")
    print("-" * 90)
    print(f"{'DCA Buys':<20} {metrics['dca_buys']:>20}")
    print(f"{'AI Trades':<20} {metrics['total_trades']:>20}")
    print(f"{'AI Win Rate':<20} {metrics['win_rate']*100:>19.1f}%")
    print("=" * 90)
    
    # =========================================================================
    # 視覺化
    # =========================================================================
    fig, axes = plt.subplots(2, 1, figsize=(16, 12))
    
    equity_df = metrics['equity_df']
    
    # 子圖 1: Portfolio Value 比較
    ax1 = axes[0]
    ax1.plot(equity_df.index, equity_df['value'], label='DCA+AI Hybrid', color='blue', linewidth=2)
    ax1.plot(dca_bench['equity_df'].index, dca_bench['equity_df']['value'], 
             label='Pure DCA (50k/mo)', color='orange', linewidth=1.5, linestyle='--')
    ax1.plot(lump_bench['equity_df'].index, lump_bench['equity_df']['value'], 
             label='Yearly Lump Sum', color='gray', linewidth=1.5, alpha=0.7)
    
    date_range_str = f"{twii_backtest_df.index[0].strftime('%Y-%m-%d')} ~ {twii_backtest_df.index[-1].strftime('%Y-%m-%d')}"
    ax1.set_title(f'DCA+AI Hybrid No-Filter vs Benchmarks ({date_range_str})', fontsize=14)
    ax1.set_ylabel('Portfolio Value ($)')
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)
    
    # 績效摘要
    summary_text = (
        f"{'Metric':<10} {'Hybrid':>10} {'DCA':>10} {'Lump':>10}\n"
        f"{'-'*44}\n"
        f"{'Invested':.<10} ${metrics['total_invested']/1e6:>8.1f}M ${dca_bench['total_invested']/1e6:>8.1f}M ${lump_bench['total_invested']/1e6:>8.1f}M\n"
        f"{'Final':.<10} ${metrics['final_value']/1e6:>8.1f}M ${dca_bench['final_value']/1e6:>8.1f}M ${lump_bench['final_value']/1e6:>8.1f}M\n"
        f"{'Return':.<10} {metrics['total_return']*100:>9.1f}% {dca_bench['total_return']*100:>9.1f}% {lump_bench['total_return']*100:>9.1f}%\n"
        f"{'Annual':.<10} {metrics['annualized_return']*100:>9.1f}% {dca_bench['annualized_return']*100:>9.1f}% {lump_bench['annualized_return']*100:>9.1f}%\n"
        f"{'Sharpe':.<10} {metrics['sharpe_ratio']:>10.2f} {dca_bench['sharpe_ratio']:>10.2f} {lump_bench['sharpe_ratio']:>10.2f}\n"
        f"{'Max DD':.<10} {metrics['max_drawdown']*100:>9.1f}% {dca_bench['max_drawdown']*100:>9.1f}% {lump_bench['max_drawdown']*100:>9.1f}%"
    )
    
    props = dict(boxstyle='round,pad=0.5', facecolor='white', alpha=0.9, edgecolor='gray')
    ax1.text(0.98, 0.03, summary_text, transform=ax1.transAxes, fontsize=9,
             verticalalignment='bottom', horizontalalignment='right',
             bbox=props, family='monospace')
    
    # 子圖 2: 價格與交易訊號
    ax2 = axes[1]
    price_slice = twii_backtest_df['Close']
    ax2.plot(price_slice.index, price_slice.values, label='^TWII', color='black', linewidth=1)
    
    # DCA 買入點 (小圓點)
    if backtester.dca_buy_signals:
        dca_dates, dca_prices, _ = zip(*backtester.dca_buy_signals)
        ax2.scatter(dca_dates, dca_prices, marker='o', color='orange', s=30, label='DCA Buy', alpha=0.6, zorder=4)
    
    # AI 買入點 (三角形)
    if backtester.ai_buy_signals:
        ai_buy_dates, ai_buy_prices = zip(*backtester.ai_buy_signals)
        ax2.scatter(ai_buy_dates, ai_buy_prices, marker='^', color='red', s=100, label='AI Buy', zorder=5)
    
    # AI 賣出點 (倒三角形)
    if backtester.ai_sell_signals:
        ai_sell_dates, ai_sell_prices = zip(*backtester.ai_sell_signals)
        ax2.scatter(ai_sell_dates, ai_sell_prices, marker='v', color='green', s=100, label='AI Sell', zorder=5)
    
    ax2.set_title('Trade Signals (DCA + AI No-Filter)', fontsize=14)
    ax2.set_ylabel('Price')
    ax2.set_xlabel('Date')
    ax2.legend(loc='upper left')
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    # 儲存
    start_str = twii_backtest_df.index[0].strftime('%Y%m%d')
    end_str = twii_backtest_df.index[-1].strftime('%Y%m%d')
    save_path = os.path.join(RESULTS_PATH, f'backtest_v4_dca_hybrid_no_filter_{start_str}_{end_str}.png')
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    print(f"\n[Output] Chart: {save_path}")
    plt.close()
    
    # =========================================================================
    # 儲存 CSV
    # =========================================================================
    metrics_df = pd.DataFrame({
        'Metric': ['Total_Invested', 'Final_Value', 'Total_Return_Pct', 'Annualized_Return_Pct',
                   'Sharpe_Ratio', 'Max_Drawdown_Pct', 'DCA_Buys', 'AI_Trades', 'AI_Win_Rate_Pct'],
        'DCA_AI_Hybrid': [metrics['total_invested'], metrics['final_value'], metrics['total_return']*100,
                          metrics['annualized_return']*100, metrics['sharpe_ratio'], metrics['max_drawdown']*100,
                          metrics['dca_buys'], metrics['total_trades'], metrics['win_rate']*100],
        'Pure_DCA_50k': [dca_bench['total_invested'], dca_bench['final_value'], dca_bench['total_return']*100,
                         dca_bench['annualized_return']*100, dca_bench['sharpe_ratio'], dca_bench['max_drawdown']*100,
                         'N/A', 'N/A', 'N/A'],
        'Yearly_Lump_Sum': [lump_bench['total_invested'], lump_bench['final_value'], lump_bench['total_return']*100,
                            lump_bench['annualized_return']*100, lump_bench['sharpe_ratio'], lump_bench['max_drawdown']*100,
                            'N/A', 'N/A', 'N/A']
    })
    metrics_path = os.path.join(RESULTS_PATH, f'metrics_v4_dca_hybrid_no_filter_{start_str}_{end_str}.csv')
    metrics_df.to_csv(metrics_path, index=False, encoding='utf-8-sig')
    print(f"[Output] Metrics: {metrics_path}")
    
    # 交易明細
    if backtester.trades:
        trades_df = pd.DataFrame(backtester.trades)
        trades_path = os.path.join(RESULTS_PATH, f'trades_v4_dca_hybrid_no_filter_{start_str}_{end_str}.csv')
        trades_df.to_csv(trades_path, index=False)
        print(f"[Output] Trades: {trades_path}")
        
        print("\n[AI Trades] Last 5:")
        print(trades_df.tail().to_string(index=False))
    
    print("\n" + "=" * 70)
    print("Backtest completed!")
    print("=" * 70)


if __name__ == "__main__":
    main()
